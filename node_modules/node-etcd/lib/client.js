// Generated by CoffeeScript 1.6.3
var CancellationToken, Client, defaultClientOptions, defaultRequestOptions, exports, request, _,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

request = require('request');

_ = require('underscore');

defaultRequestOptions = {
  pool: {
    maxSockets: 100
  },
  followAllRedirects: true
};

defaultClientOptions = {
  maxRetries: 3
};

CancellationToken = (function() {
  function CancellationToken(servers, maxRetries, retries, errors) {
    this.servers = servers;
    this.maxRetries = maxRetries;
    this.retries = retries != null ? retries : 0;
    this.errors = errors != null ? errors : [];
    this.abort = __bind(this.abort, this);
    this.isAborted = __bind(this.isAborted, this);
    this.setRequest = __bind(this.setRequest, this);
    this.aborted = false;
  }

  CancellationToken.prototype.setRequest = function(req) {
    return this.req = req;
  };

  CancellationToken.prototype.isAborted = function() {
    return this.aborted;
  };

  CancellationToken.prototype.abort = function() {
    this.aborted = true;
    if (this.req != null) {
      return this.req.abort();
    }
  };

  CancellationToken.prototype.cancel = CancellationToken.prototype.abort;

  return CancellationToken;

})();

Client = (function() {
  function Client(hosts, sslopts) {
    this.hosts = hosts;
    this.sslopts = sslopts;
    this._shouldRetry = __bind(this._shouldRetry, this);
    this._retry = __bind(this._retry, this);
    this._multiserverHelper = __bind(this._multiserverHelper, this);
    this["delete"] = __bind(this["delete"], this);
    this.patch = __bind(this.patch, this);
    this.post = __bind(this.post, this);
    this.get = __bind(this.get, this);
    this.put = __bind(this.put, this);
    this.execute = __bind(this.execute, this);
  }

  Client.prototype.execute = function(method, options, callback) {
    var opt, servers, token;
    opt = _.defaults(_.clone(options), defaultRequestOptions, {
      method: method
    });
    opt.clientOptions = _.defaults(opt.clientOptions, defaultClientOptions);
    servers = _.shuffle(this.hosts);
    token = new CancellationToken(servers, opt.clientOptions.maxRetries);
    this._multiserverHelper(servers, opt, token, callback);
    return token;
  };

  Client.prototype.put = function(options, callback) {
    return this.execute("PUT", options, callback);
  };

  Client.prototype.get = function(options, callback) {
    return this.execute("GET", options, callback);
  };

  Client.prototype.post = function(options, callback) {
    return this.execute("POST", options, callback);
  };

  Client.prototype.patch = function(options, callback) {
    return this.execute("PATCH", options, callback);
  };

  Client.prototype["delete"] = function(options, callback) {
    return this.execute("DELETE", options, callback);
  };

  Client.prototype._multiserverHelper = function(servers, options, token, callback) {
    var host, req, reqRespHandler,
      _this = this;
    host = _.first(servers);
    options.url = "" + options.serverprotocol + "://" + host + options.path;
    if (token.isAborted()) {
      return;
    }
    if (host == null) {
      if (this._shouldRetry(token)) {
        return this._retry(token, options, callback);
      }
      return this._error(token, callback);
    }
    reqRespHandler = function(err, resp, body) {
      if (token.isAborted()) {
        return;
      }
      if (_this._isHttpError(err, resp)) {
        token.errors.push({
          server: host,
          httperror: err,
          httpstatus: resp != null ? resp.statusCode : void 0,
          httpbody: resp != null ? resp.body : void 0,
          response: resp,
          timestamp: new Date()
        });
        return _this._multiserverHelper(_.rest(servers), options, token, callback);
      }
      return _this._handleResponse(err, resp, body, callback);
    };
    req = request(options, reqRespHandler);
    return token.setRequest(req);
  };

  Client.prototype._retry = function(token, options, callback) {
    var doRetry, waitTime,
      _this = this;
    doRetry = function() {
      return _this._multiserverHelper(token.servers, options, token, callback);
    };
    waitTime = this._waitTime(token.retries);
    token.retries += 1;
    return setTimeout(doRetry, waitTime);
  };

  Client.prototype._waitTime = function(retries) {
    if (process.env.RUNNING_UNIT_TESTS === 'true') {
      return 1;
    }
    return 100 * Math.pow(16, retries);
  };

  Client.prototype._shouldRetry = function(token) {
    return token.retries < token.maxRetries && this._isPossibleLeaderElection(token.errors);
  };

  Client.prototype._error = function(token, callback) {
    var error;
    error = new Error('All servers returned error');
    error.errors = token.errors;
    error.retries = token.retries;
    if (callback) {
      return callback(error);
    }
  };

  Client.prototype._isPossibleLeaderElection = function(errors) {
    var checkError;
    checkError = function(e) {
      var _ref, _ref1, _ref2, _ref3;
      return ((_ref = e != null ? (_ref1 = e.httperror) != null ? _ref1.code : void 0 : void 0) === 'ECONNREFUSED' || _ref === 'ECONNRESET') || ((_ref2 = e != null ? (_ref3 = e.httpbody) != null ? _ref3.errorCode : void 0 : void 0) === 300 || _ref2 === 301) || /Not current leader/.test(e != null ? e.httpbody : void 0);
    };
    return (errors != null) && _.every(errors, checkError);
  };

  Client.prototype._isHttpError = function(err, resp) {
    return err || (((resp != null ? resp.statusCode : void 0) != null) && resp.statusCode >= 500);
  };

  Client.prototype._handleResponse = function(err, resp, body, callback) {
    var error;
    if (callback == null) {
      return;
    }
    if ((body != null ? body.errorCode : void 0) != null) {
      error = new Error((body != null ? body.message : void 0) || 'Etcd error');
      error.errorCode = body.errorCode;
      error.error = body;
      return callback(error, "", (resp != null ? resp.headers : void 0) || {});
    } else {
      return callback(null, body, (resp != null ? resp.headers : void 0) || {});
    }
  };

  return Client;

})();

exports = module.exports = Client;
